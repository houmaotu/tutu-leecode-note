String 1 Rotational Cipher 

import math
import string
# Add any extra import statements you may need here


# Add any helper functions you may need here


def rotationalCipher(input, rotation_factor):
  # Write your code here
  l1 = 'abcdefghijklmnopqrstuvwxyz'
  lib1,lib2 = {},{}
  for i,ch in enumerate(l1):
    lib1[i] = ch
    lib2[ch] = i
  #print(lib1)
  #print(lib2)
  res = ''
  for ch in input:
    if ch.islower():
      key = (lib2[ch]++rotation_factor)%26
      res += lib1[key]
    elif ch.isupper():
      key = (lib2[ch.lower()]++rotation_factor)%26
      res += lib1[key].upper()
    elif ch.isdigit():
      res += str ((int(ch)+rotation_factor)%10)
    else:
      res += ch
  return res
  
  Array 3
  Contiguous Subarrays where n is the max and the start/end
  import math
# Add any extra import statements you may need here


# Add any helper functions you may need here


def count_subarrays(arr):
  # Write your code here
  n = len(arr)
  if n == 1:
    return [1]
  stop,start =  [1] *n, [1] * n
  for i in range(1,n):
    j = i-1
    while j>=0 and arr[j]<arr[i]:
      j -= 1
    stop[i] += (i-j-1)
  for i in range(n-2,-1,-1):
    j = i+1
    while j<=n-1 and arr[j]<arr[i]:
      j += 1
    start[i] += (j-i-1)
  return[start[i] + stop[i] - 1 for i in range(n)]
  
Hash 1 Pair Sums


def numberOfWays(arr, k):
   # Write your code here
    c = collections.Counter(arr)
    res = 0
    ##print(arr)
    #print(c)
    for num in c:
      if 2 * num == k:
        res += c[num] * (c[num]-1)
      else:
        res += c[num] * c[k - num]
        #print(num,res)
    return res//2
    
    Reverse to Make Equal
    
    
Array 1    Reverse to Make Equal
def are_they_equal(array_a, array_b):
  # Write your code here
  n = len(array_a)
  l,r = 0, n-1
  while l<=n-1 and array_a[l]==array_b[l]:
    l+=1  #l-1 same l not
  if l==n:
    return True
  while r>=0 and array_a[r]==array_b[r]:
    r-= 1 #r+! same r not
  #print(array_a)
  #print(array_b)
  #print(l,r)
  return array_a[l:(r+1)] == array_b[r:(l-1):-1]
  
     
Array 2    Passing Yearbooks

def findSignatureCounts(arr):
  # Write your code here
  n = len(arr)
  res = [None] * n
  for i in range(n):
    if res is not None:
      ct = 1
      s= i+1
      c = i+1
      index = set([c])
      while arr[c - 1] != s:
        ct += 1
        c = arr[c - 1]
        index.add(c)
      for ind in index:
        res[ind-1] = ct
  return res
  
  heap 1 Largest Triple Products
  def findMaxProduct(arr):
  # Write your code here
    n = len(arr)
    if n <= 2:
        return [-1]* n
    if n == 3:
        return [-1,-1,arr[0]*arr[1]*arr[2]]
    res = [-1]* n
    res[2] = arr[0]*arr[1]*arr[2]
    Heap = arr[0:3]
    heapq.heapify(Heap)
    for i in range(3,n):
        if Heap[0] < arr[i]:
            heapq.heappop(Heap)
            heapq.heappush(Heap,arr[i])
        res[i] = Heap[0]* Heap[1] * Heap[2]

    return res
    
 Heap 2 Magical Candy Bags
 
 def maxCandies(arr, k):
  # Write your code here
    Heap = [-arr[i] for i in range(len(arr))]
    heapq.heapify(Heap)
    res = 0
    for _ in range(k):
        num = -heapq.heappop(Heap)
        res += num
        heapq.heappush(Heap,-(num//2))
    return res
    
    Heap  3 Median Stream
    
    def findMedian(arr):
    m = []
    n = len(arr)
    res = [None] * n
    for i in range(n):
        m.append(arr[i])
        m.sort()
        if len(m) <=2:
            res[i] = (m[0]+m[-1])//2
        elif len(m) == 3:
            res[i] = m[1]
        else:
            res[i] = (m[1]+m[2])//2
            m = m[1:3]
                        
    return res
    
    String 2: Matching Pairs fk those edge cases
def matching_pairs(s, t):
  # Write your code here
    n = len(s)
    if s == t:
        return n-2 if len(set(s)) == len(s) else n       
    ct = 0
    misses,pairs = set(),set()
    for si,ti in zip(s,t):
        if si == ti:
            pairs.add((si,True))
            ct += 1
        else:
            misses.add((si,ti))
            pairs.add((si,False))
    for m in misses:
        if (m[1],m[0]) in misses:
            return ct+2
    for m in misses:
        if (m[1],False) in pairs:
            return ct+1
    for m in misses:
        if (m[1], True) in pairs: 
            return ct
    if len(set(s)) == len(s):
        return ct
    if len(misses) >= 2:
        return ct
    if len(misses) == 1:
        return ct
    return ct - 2
  
